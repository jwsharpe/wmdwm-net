<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EINAR ARENA 2</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #gameCanvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 24px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 100;
      }
      #instructions {
        position: absolute;
        top: 80px;
        left: 20px;
        color: white;
        font-size: 16px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 100;
      }
      #timer {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 32px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 100;
      }
      .menu {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
      }
      .menu h1 {
        color: #ff6b35;
        font-size: 72px;
        margin: 20px;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
      }
      .menu button {
        background: #cc0000;
        color: white;
        border: 3px solid #000;
        padding: 15px 40px;
        font-size: 24px;
        margin: 10px;
        cursor: pointer;
        font-family: Arial, sans-serif;
        text-transform: uppercase;
        transition: all 0.2s;
      }
      .menu button:hover {
        background: #ff0000;
        transform: scale(1.05);
      }
      .hidden {
        display: none !important;
      }
      #gameOverScreen h2 {
        color: #ff6b35;
        font-size: 48px;
        margin: 10px;
      }
      #gameOverScreen p {
        color: white;
        font-size: 32px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Main Menu -->
    <div id="mainMenu" class="menu">
      <h1>EINAR ARENA II</h1>
      <button onclick="startGame()">START</button>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="menu hidden">
      <h1>PAUSED</h1>
      <button onclick="continueGame()">CONTINUE</button>
      <button onclick="restartGame()">RESTART</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="menu hidden">
      <h2>EINAR OVER!</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <p>High Score: <span id="highScore">0</span></p>
      <button onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <div id="ui" class="hidden">
      <div>Score: <span id="score">0</span></div>
    </div>
    <div id="timer" class="hidden">
      <span id="timeLeft">30</span>
    </div>
    <div id="instructions" class="hidden">
      W/S or Up/Down to move forward/back | A/D or Left/Right to rotate | Space
      to jump | ESC to pause
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Game state
      let gameState = "menu"; // 'menu', 'playing', 'paused', 'gameover'
      let gameTime = 30; // seconds
      let timeLeft = gameTime;
      let timerInterval = null;
      let highScoreValue =
        parseInt(localStorage.getItem("einarArena2HighScore")) || 0;

      // Game setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xff6b35); // Sunset orange
      scene.fog = new THREE.Fog(0x556b35, 10, 70);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(100, 100);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Black grid overlay
      const gridHelper = new THREE.GridHelper(100, 50, 0x000000, 0x000000);
      gridHelper.position.y = 0.01; // Slightly above ground to avoid z-fighting
      scene.add(gridHelper);

      // clouds
      const clouds = [];
      for (let i = 0; i < 100; i++) {
        const cloudGeometry = new THREE.SphereGeometry(
          8 + Math.random() * 2,
          8,
          8
        );
        const cloudMaterial = new THREE.MeshBasicMaterial({
          color: 0x888888,
          transparent: true,
          opacity: 0.2,
          wireframe: false,
        });
        const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);

        // Random position in the sky
        const angle = (i / 12) * Math.PI * 2;
        const distance = 40 + Math.random() * 20;
        cloud.position.x = Math.cos(angle) * distance;
        cloud.position.y = 10 + Math.random() * 10;
        cloud.position.z = Math.sin(angle) * distance;

        scene.add(cloud);
        clouds.push(cloud);
      }

      // Background music
      const music = new Audio();
      music.src = "./einus-arena/circus.ogg";
      music.loop = true;
      music.volume = 0.25;

      // Start music on first user interaction
      let musicStarted = false;
      const startMusic = () => {
        if (!musicStarted) {
          music.play().catch((e) => console.log("Music autoplay prevented"));
          musicStarted = true;
        }
      };

      // Player
      const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
      const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x6d0e02 });
      const player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.position.y = 0.5;
      player.castShadow = true;
      scene.add(player);

      // Player properties
      const playerSpeed = 0.1;
      const rotationSpeed = 0.03;
      const jumpForce = 0.3;
      let velocityY = 0;
      const gravity = -0.015;
      let isJumping = false;
      let playerRotation = 0;
      let cameraRotation = 0;
      const cameraRotationSpeed = 0.1; // Camera catches up at this rate

      // Enemies
      const enemies = [];
      const maxEnemies = 32;

      function createEnemy() {
        const enemyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
        const enemyMaterial = new THREE.MeshLambertMaterial({
          color: 0xd86720,
        });
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

        // Random position away from player
        const angle = Math.random() * Math.PI * 2;
        const distance = 10 + Math.random() * 20;
        enemy.position.x = Math.cos(angle) * distance;
        enemy.position.z = Math.sin(angle) * distance;
        enemy.position.y = 0.5;

        enemy.castShadow = true;
        enemy.active = true;

        scene.add(enemy);
        enemies.push(enemy);
      }

      // Spawn initial enemies
      for (let i = 0; i < maxEnemies; i++) {
        createEnemy();
      }

      // Input handling
      const keys = {};
      window.addEventListener("keydown", (e) => {
        if (gameState !== "playing") return;

        keys[e.key.toLowerCase()] = true;

        if ((e.key === " " || e.key === "Spacebar") && !isJumping) {
          velocityY = jumpForce;
          isJumping = true;
        }

        if (e.key === "Escape") {
          pauseGame();
        }
      });

      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      // Escape key for pause
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && gameState === "playing") {
          pauseGame();
        }
      });

      // Score
      let score = 0;
      const scoreElement = document.getElementById("score");

      function updateScore(points) {
        score += points;
        scoreElement.textContent = score;
      }

      function resetScore() {
        score = 0;
        scoreElement.textContent = score;
      }

      // Timer functions
      function startTimer() {
        timeLeft = gameTime;
        document.getElementById("timeLeft").textContent = timeLeft;

        timerInterval = setInterval(() => {
          timeLeft--;
          document.getElementById("timeLeft").textContent = timeLeft;

          if (timeLeft <= 0) {
            endGame();
          }
        }, 1000);
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      // Game state functions
      function startGame() {
        gameState = "playing";
        document.getElementById("mainMenu").classList.add("hidden");
        document.getElementById("ui").classList.remove("hidden");
        document.getElementById("timer").classList.remove("hidden");
        document.getElementById("instructions").classList.remove("hidden");

        resetScore();
        startTimer();
        startMusic();

        // Reset player position
        player.position.set(0, 0.5, 0);
        playerRotation = 0;
        player.rotation.y = 0;
      }

      function pauseGame() {
        if (gameState !== "playing") return;

        gameState = "paused";
        document.getElementById("pauseMenu").classList.remove("hidden");
        stopTimer();
        music.pause();
      }

      function continueGame() {
        gameState = "playing";
        document.getElementById("pauseMenu").classList.add("hidden");
        resumeTimer();
        music.play();
      }

      function resumeTimer() {
        timerInterval = setInterval(() => {
          timeLeft--;
          document.getElementById("timeLeft").textContent = timeLeft;

          if (timeLeft <= 0) {
            endGame();
          }
        }, 1000);
      }

      function endGame() {
        gameState = "gameover";
        stopTimer();

        // Update high score
        if (score > highScoreValue) {
          highScoreValue = score;
          localStorage.setItem("einarArena2HighScore", highScoreValue);
        }

        document.getElementById("finalScore").textContent = score;
        document.getElementById("highScore").textContent = highScoreValue;
        document.getElementById("gameOverScreen").classList.remove("hidden");
        document.getElementById("ui").classList.add("hidden");
        document.getElementById("timer").classList.add("hidden");
        document.getElementById("instructions").classList.add("hidden");
      }

      function restartGame() {
        gameState = "playing";
        document.getElementById("pauseMenu").classList.add("hidden");
        document.getElementById("gameOverScreen").classList.add("hidden");
        document.getElementById("ui").classList.remove("hidden");
        document.getElementById("timer").classList.remove("hidden");
        document.getElementById("instructions").classList.remove("hidden");

        resetScore();
        startTimer();
        music.play();

        // Reset player position
        player.position.set(0, 0.5, 0);
        playerRotation = 0;
        player.rotation.y = 0;
        velocityY = 0;
        isJumping = false;
      }

      // Camera follow player
      function updateCamera() {
        // Smoothly interpolate camera rotation towards player rotation
        const rotationDiff = playerRotation - cameraRotation;
        cameraRotation += rotationDiff * cameraRotationSpeed;

        // Position camera behind and above the player based on camera rotation
        const cameraDistance = 12;
        const cameraHeight = 8;

        camera.position.x =
          player.position.x + Math.sin(cameraRotation) * cameraDistance;
        camera.position.y = player.position.y + cameraHeight;
        camera.position.z =
          player.position.z + Math.cos(cameraRotation) * cameraDistance;
        camera.lookAt(player.position.x, player.position.y, player.position.z);
      }

      const enemySound = new Audio();
      enemySound.src = "./einus-arena/coin.mp3";
      enemySound.volume = 0.3;

      function checkEnemyCollision() {
        for (let i = 0; i < enemies.length; i++) {
          const enemy = enemies[i];
          if (!enemy.active) continue;

          const dx = player.position.x - enemy.position.x;
          const dy = player.position.y - enemy.position.y;
          const dz = player.position.z - enemy.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz); // Horizontal distance only
          const collisionRadius = 0.8; // Combined radius for collision

          // If player is above enemy and close enough (stomping)
          if (distance < 1 && dy <= 1 && velocityY < 0) {
            // Destroy enemy
            enemy.active = false;
            scene.remove(enemy);
            enemies.splice(i, 1);
            enemySound.play().catch((e) => {});

            // Add points
            updateScore(10);

            // Small bounce
            velocityY = 0.15;

            // Spawn new enemy
            setTimeout(() => createEnemy(), 500);

            break;
          }
          // Horizontal collision - push player away
          else if (distance < collisionRadius && Math.abs(dy) < 1) {
            // Calculate push direction
            const pushAngle = Math.atan2(dx, dz);
            const pushDistance = collisionRadius - distance;

            // Push player away from enemy
            player.position.x += Math.sin(pushAngle) * pushDistance;
            player.position.z += Math.cos(pushAngle) * pushDistance;
          }
        }
      }

      const targetFPS = 120;
      const frameDelay = 1000 / targetFPS;
      let lastFrameTime = 0;

      function animate(currentTime) {
        requestAnimationFrame(animate);

        const deltaTime = currentTime - lastFrameTime;
        if (deltaTime < frameDelay) {
          return;
        }
        lastFrameTime = currentTime - (deltaTime % frameDelay);

        if (gameState === "playing") {
          // Player movement - Tank controls
          if (keys["w"] || keys["arrowup"]) {
            // Move forward in the direction player is facing
            player.position.x -= Math.sin(playerRotation) * playerSpeed;
            player.position.z -= Math.cos(playerRotation) * playerSpeed;
          }
          if (keys["s"] || keys["arrowdown"]) {
            // Move backward
            player.position.x += Math.sin(playerRotation) * playerSpeed;
            player.position.z += Math.cos(playerRotation) * playerSpeed;
          }
          if (keys["a"] || keys["arrowleft"]) {
            // Rotate left
            playerRotation += rotationSpeed;
            player.rotation.y = playerRotation;
          }
          if (keys["d"] || keys["arrowright"]) {
            // Rotate right
            playerRotation -= rotationSpeed;
            player.rotation.y = playerRotation;
          }

          // Keep player in bounds
          player.position.x = Math.max(-45, Math.min(45, player.position.x));
          player.position.z = Math.max(-45, Math.min(45, player.position.z));

          // Apply gravity
          velocityY += gravity;
          player.position.y += velocityY;

          // Ground collision
          if (player.position.y <= 0.5) {
            player.position.y = 0.5;
            velocityY = 0;
            isJumping = false;
          }

          // Check enemy collisions
          checkEnemyCollision();

          // Animate enemies (slight bobbing)
          enemies.forEach((enemy, index) => {
            if (enemy.active) {
              enemy.position.y =
                0.5 + Math.sin(Date.now() * 0.002 + index) * 0.1;
              enemy.rotation.y += 0.01;
            }
          });
        }

        // Animate clouds (slow drift) - always animate
        clouds.forEach((cloud, index) => {
          cloud.rotation.y += 0.001;
          cloud.position.x += Math.sin(Date.now() * 0.0001 + index) * 0.02;
          cloud.position.z += Math.cos(Date.now() * 0.0001 + index) * 0.02;
        });

        updateCamera();
        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize high score display
      document.getElementById("highScore").textContent = highScoreValue;

      animate(performance.now());
    </script>
  </body>
</html>
